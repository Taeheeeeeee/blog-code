# 2024 우아콘

## 배달의 민족 API Gateway

API gateway는 크게 2가지 범주

- 라우팅
  - 클라이언트 요청을 적절한 서비스로 전달
- 하위 서비스들의 횡단 관심사 문제를 다룬다
  - 인증, 보안, 모니터링, 탄력성

### 배민에서 왜 API Gateway가 필요한걸까?

하나의 지면을 표현하는데 단일 End Point로 처리하기 힘든 상황에 도달

클라이언트가 여러 시스템과 직접 상호작용 하면서 문제가 발생
- 클라이언트 의존성 증가로 인한 확장성 저하
  - 서비스 간 느슨한 연결이 어려움
- 불필요한 정보가 클라이언트에 노출
  - email만 필요하지만 기존 API가 여러 개인정보를 노출하는 경우 문제가 발생
- 클라이언트에 비즈니서 정책이 노출
  - 클라이언트에 내부에서만 알고 있어야할 비즈니스 정책 (로직)이 노출

API Gateway Pattern
- 클라이언트 스펙을 담당하는 중간 API 계층을 둔다
- = 프론트 서버

MSA에서 도메인들이 분할되면서 발생하는 문제를 프론트 서버가 해소
= MSA에서 도메인들이 분할되면서 발생하는 문제 때문에 API Gateway가 필요한게 아님

각각의 비즈니스 영역에 프론트 서버들이 증가하기 시작함
- 프론트 서버들이 여러개로 늘어나면서 횡단 관심사의 문제가 늘어남

횡단 관심사를 공유하는 시스템의 수가 많아질수록 유지보수에 들어가는 비용이 증가
- MSA 라는건 마이크로서비스가 계속 늘어날 수 밖에 없고
- 자연스럽게 횡단관심사의 문제가 점점 커질 수 밖에 없음

횡단 관심사의 문제를 해결할 계층이 추가하고, 이걸 API Gateway로 해결한다

### API Gateway 와 API Gateway Pattern

API Gateway != API Gateway Pattern
- 개념을 그림으로 그리면 거의 비슷하게 보임
- 세부적으로 살펴보면 차이가 있음

API Gateway Pattern
- 클라이언트 요구사항을 전담하는 클라이언트 문제를 해결하는 데 초점

API Gateway
- 서버들간의 횡단 관심사 문제를 해결하는데 초점이 있는 계층

1. API Gateway로 API Gateway Pattern이 해결해주는 문제를 해결해 줄 수 없다.
2. API Gateway는 API Gateway Pattern이 적용된 서버와 연결해야한다
- 도메인 시스템과 클라이언트 간 통신에서 발생하는 문제를 해결해주는 서버

### 배달의 민족 API Gateway

API Gateway가 SPOF가 되지 않기 위해

- 단순히 scale up/out만 있는게 아니면 클러스터 군을 분산해서 관리
  - 물리적 분산/스케일

Spring Cloud Gateway
- properties 기반 -> database 에서 설정 관리
- 다양한 종류의 필터가 지원
  - 별도의 필터 체인을 만들어서 사용

주요 기능

- 인증
  - JWT로 처리하려고 시도했었음
    - 인증 시스템이 장애났을 때 대비
    - 다만 JWT 처리 로직을 분산된 모든 시스템이 관리를 하고 있어야함
    - 특히 인증 로직 문제가 발생할 경우 전체 시스템 반영이 어려움
  - API Gateway가 인증을 처리하고 뒷 단 시스템은 passport 전달
  - 인증 시스템 장애시 API Gateway에서 JWT 로직 처리만 하면 되니 빠르게 대응 가능
    - 변경사항이 있어도 API Gateway 에서만 반영하면 됨
- 라우팅
  - IP 대역, PATH 기반, 도메인 기반 등으로 라우팅 가능
  - 사용자 식별 정보를 활용해서 라우팅도 가능
- 보안
  - 어뷰징에 대한 방어 등
- 흐름제어 (탄력성)
  - Rate Limiting
  - 써킷 브레이커
  - Retry
  - Fallback
  - Static Response

## Kafka를 이용하는 메세지 플랫폼에서 장애를 겪으면 아키텍쳐를 개선한 이야기

- 월간 2건의 장애가 발생중인 메세지 플랫폼
  - 통신사/FCM 43.9%, 내부버그 29%, 벤더사 장애 17%, 카프카 장애 9.8%

### 아키텍처 개선 이야기

2023년 3번의 대형 장애 발생
- 특정 파티션의 컨슘 중단

Kafka Exactly Once
- 메세지를 단 한번만 전달하는 기능
- 멱등성 Producer
  - Producer와 파티션 사이의 중복 방비
- 트랜잭션
  - 트랜잭셔널 프로듀서로 여러 메세지를 트랜잭션으로 묶어서 처리 할 수 있음

왜 사용하게 되었나?
- 아래 요구사항을 만족시키기 위함
  - API 한번의 호출로 최대 100명에게 전달해야하는 요구사항
  - 메세지 중복 발신 방지
- 직접 구현 보다 적정 수준의 중복을 방지하고, 인프라 비용이 감소하고 아키텍처가 심플해짐
  
Exactly Once 제거 결정 
- 종종 발생하는 장애가 있었고, 이는 계속 모니터링하고 사람이 직접 운영적으로 해결을 해야하는 상황이 계속 발생
- 플랫폼 유지 비용 증가

직접 구현
- hash
  - API 요청마다 producer에서 hash 키 생성하여 발행
- redis에서 cache
  - consumer에서 중복 검증
- 카프카 내부에서 발생하는 중복만 제거

캐시 용량 예측
- 예측은 1.65G
- 실제 용량은 3.8G여서 예상보다 높은 용량으로 Redis 부하로 롤백 결정
  - memory usage가 272b로 예측 값의 2.5배였음

메모리 최대를 사용하면 안되나?

### 3배 트래픽을 위한 여정

단순히 파티션 증가만으로는 동시성/트래픽 처리에 답이 아닌 이유
- 파티션 수 증가시
  - 장애 복구 타임 증가
  - 커밋 레이턴시 증가
  - 늘어난 파티션은 줄일 수 없음
- 효과는 불확실하고 비용과 리스크는 커지는데 비가역적

어디가 병목일까?
- 아웃 라이어 제거
  - 순간적인 레이턴시 증가
    - 순차적이 아닌, 갑작스런 증가
  - Sender -> FCM
  - 15분 이상 미응답 (리밸런싱 발생)
    - 타임아웃을 짧게 잡아도 15분이상 미 응답이 발생하고 리밸런싱 발생
- Sender <-> Time Limiter <-> FCM
  - 늘어나는 트래픽에 따라 점진적 레이턴시 증가로 해소

이것만으로는 동시 처리량 증가를 해결할 수 없어서 동시처리량 증가를 위한 개선 시작
- 굳이 발송 결과를 알고 다음 푸시를 보내야 할까?
- 모두 독립적이고 순서도 중요하지 않은데?

비동기 전환
- Sender Thread
  - 일시적인 실패 재처리를 어떻게 할 것인가?
  - 적절한 동시성이 어느정도인지 찾기
- 쓰레드풀 최적화
  - 적절한 크기의 스레드 풀을 도입하여 트래픽 평탄화 필요
  - 목적에 다른 쓰레드풀 분리
    - Sender Thread를 Metadat Thread / Sender Thread로 분리
    - 푸시메타 정보 가져오기 / 푸시발송
  - 트래픽 성격에 따른 쓰레드풀 분리
    - Batch Thread: 주기적/피크성
    - Realtime Thread: 점진적
    - Ad Thread: 비정기적/대량

정리
- 파티션수 720 -> 100개
- 2배 트래픽 최대 1분이내 지연발송까지 확인

## Fine tuning 없이 프롬프트 엔지니어링으로 메뉴 이미지 검수하기

- 메뉴 이미지가 가게를 결정하는 중요한 요소
- 가게 중심 리스팅 방식 -> 메뉴 중심 리스팅 방식
- 배민 셀프 서비스에서 메뉴 이미지 등록시 검수 과정이 평균 17시간 소요
  - 일평균 1만건 이상 검수
- 메뉴 이미지 반려 기준
  - 음식이 아닌 이미지
  - 저화질
  - 불필요한 장식 포함
  - 음식 중앙 배치
  - 부적절한 용기
  - 저작권/상표권/초상권
  - 메뉴명 불일치

생성형 AI를 활용해서 사장님들이 배민 정책에 맞는 메뉴 이미지를 손쉽게 등록할 수 있도록 하자.

### 프롬프트 정책 구체화

정책을 위반하는
- 정책에 해당하는

합성
- 인위적인 텍스트를 합성한 이미지
- 여러 장의 사진을 합친 이미지
- 비현실적인 비율로 왜곡된 이미지

### Completion 출력 구조화

서비스 내 활용을 위한 Completion 출력 구조화

- Parameter 조정
  - Temperature: 모델 출력의 무작위성을 제어하는 값
  - Top-P: 누적 확률 분포 샘플링
  - 수치를 여러번 조정
- CoT
  - 이미지에 대한 설명을 요청 -> 해당 요청의 결과값 요청


프롬프트 엔지니어링 + 기존 머신러닝 모델링
